G1  
因为对于GC的时间有预估,并且分Region,因此jvm要消耗更多的资源在这一部分的计算上,因此更适合cpu计算能力强的
且G1可以设置能接受的GC时间,因此G1非常适合对响应时间要求高的应用,即使GC可能更频繁,但不会明显影响到单批用户的使用体验
对于大堆,内存配置很高的机器,也更适合用G1,因为大内存的机器,比如几十G,那么GC需要的时间会非常多,对于高响应要求的应用是无法接受的

同样,因为G1需要对于Region的数据的计算,对于cpu性能较差的机器来说,par new+cms更适合

G1中大对象不会直接进入老年代,有专门的的大对象Region

新生代占比超过60%的时候,会触发YGC,采用复制算法,将一个region的存活对象挪到另一个region,然后对这个region进行回收

老年代的region占比超过45%的时候,就会触发mixedGc,mixedGc会回收年轻代,老年代以及永久代,
mixedGc过程的最后一步执行混合回收的时候,会停止所有程序运行,也就是stw,
因此G1允许执行多次混合回收,默认值是8次,由-XX:G1MixedGCCountTarget控制
比如预计需要回收160个region,那么就每次回收掉20个region,反复执行8次以达到回收目标
在回收中如果空闲Region大小达到堆的5%,会提前结束回收

在执行mixedGc的时候,因为无论哪个代采用的都是复制算法,万一在拷贝的过程中发现没有空闲的region可以承载存活的对象了,就会触发一次失败.
一旦失败,就会立马切换为停止系统程序,然后采用单线程标记(serial old),清理和压缩.空闲出一批region,这个过程极其缓慢.

G1优化YGC,主要在于设置-XX:MaxGCPauseMills,如果设置过大,可能会导致一次回收Region过多,导致停顿时间太久
如果设置过小,会导致YGC太频繁,因此需要在不停地试探中试探出一个当前业务能够接受的范围.(频次以及停顿时间)

优化MixedGc,还是-XX:MaxGcPauseMills,如果设置过高,导致系统运行很久,新生代可能都占用了堆内存的60%了,此时才出发YGC的话,
那么存活下来的对象就可能会很多,此时就会导致survivor放不下存活的对象,导致直接进入老年代中,
或者存活对象过多,导致进入survivor以后触发了动态年龄判定规则,达到survivor区域的50%,也会导致一些对象进入老年代中

一般的优化策略就是合理加大survivor区的大小,使eden区回收后存活的对象不那么容易进入老年代,就能减少老年代的回收次数	